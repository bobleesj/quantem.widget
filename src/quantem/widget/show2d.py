"""
show2d: Static 2D image viewer with optional FFT and histogram analysis.

For displaying a single image or a static gallery of multiple images.
Unlike Show3D (interactive), Show2D focuses on static visualization.
"""

import json
import pathlib
import io
import base64
import math
from enum import StrEnum
from typing import Optional, Union, List, Self

import anywidget
import matplotlib.pyplot as plt
import numpy as np
import traitlets

from quantem.widget.array_utils import to_numpy, _resize_image
from quantem.widget.json_state import resolve_widget_version, save_state_file, unwrap_state_payload
from quantem.widget.tool_parity import (
    bind_tool_runtime_api,
    build_tool_groups,
    normalize_tool_groups,
)

_REDUCE_MODES = {"first", "index", "mean", "max", "sum"}

try:
    import h5py  # type: ignore

    _HAS_H5PY = True
except Exception:
    h5py = None  # type: ignore[assignment]
    _HAS_H5PY = False


class Colormap(StrEnum):
    INFERNO = "inferno"
    VIRIDIS = "viridis"
    MAGMA = "magma"
    PLASMA = "plasma"
    GRAY = "gray"


class Show2D(anywidget.AnyWidget):
    """
    Static 2D image viewer with optional FFT and histogram analysis.

    Display a single image or multiple images in a gallery layout.
    For interactive stack viewing with playback, use Show3D instead.

    Parameters
    ----------
    data : array_like
        2D array (height, width) for single image, or
        3D array (N, height, width) for multiple images displayed as gallery.
    labels : list of str, optional
        Labels for each image in gallery mode.
    title : str, optional
        Title to display above the image(s).
    cmap : str, default "inferno"
        Colormap name ("magma", "viridis", "gray", "inferno", "plasma").
    pixel_size : float, optional
        Pixel size in angstroms for scale bar display.
    show_fft : bool, default False
        Show FFT and histogram panels.
    show_stats : bool, default True
        Show statistics (mean, min, max, std).
    log_scale : bool, default False
        Use log scale for intensity mapping.
    auto_contrast : bool, default False
        Use percentile-based contrast.
    ncols : int, default 3
        Number of columns in gallery mode.
    disabled_tools : list of str, optional
        Tool groups to lock while still showing controls. Supported:
        ``"display"``, ``"histogram"``, ``"stats"``, ``"navigation"``,
        ``"view"``, ``"export"``, ``"roi"``, ``"profile"``, ``"all"``.
    disable_* : bool, optional
        Convenience flags (``disable_display``, ``disable_histogram``,
        ``disable_stats``, ``disable_navigation``, ``disable_view``,
        ``disable_export``, ``disable_roi``, ``disable_profile``,
        ``disable_all``) equivalent to adding those keys to
        ``disabled_tools``.
    hidden_tools : list of str, optional
        Tool groups to hide from the UI. Uses the same keys as
        ``disabled_tools``.
    hide_* : bool, optional
        Convenience flags mirroring ``disable_*`` for ``hidden_tools``.

    Examples
    --------
    >>> import numpy as np
    >>> from quantem.widget import Show2D
    >>>
    >>> # Single image with FFT
    >>> Show2D(image, title="HRTEM Image", show_fft=True, pixel_size=1.0)
    >>>
    >>> # Gallery of multiple images
    >>> labels = ["Raw", "Filtered", "FFT"]
    >>> Show2D([img1, img2, img3], labels=labels, ncols=3)
    """

    _esm = pathlib.Path(__file__).parent / "static" / "show2d.js"
    _css = pathlib.Path(__file__).parent / "static" / "show2d.css"

    # =========================================================================
    # Core State
    # =========================================================================
    widget_version = traitlets.Unicode("unknown").tag(sync=True)
    n_images = traitlets.Int(1).tag(sync=True)
    height = traitlets.Int(1).tag(sync=True)
    width = traitlets.Int(1).tag(sync=True)
    frame_bytes = traitlets.Bytes(b"").tag(sync=True)
    labels = traitlets.List(traitlets.Unicode()).tag(sync=True)
    title = traitlets.Unicode("").tag(sync=True)
    cmap = traitlets.Unicode("inferno").tag(sync=True)
    ncols = traitlets.Int(3).tag(sync=True)

    # =========================================================================
    # Display Options
    # =========================================================================
    log_scale = traitlets.Bool(False).tag(sync=True)
    auto_contrast = traitlets.Bool(False).tag(sync=True)

    # =========================================================================
    # Scale Bar
    # =========================================================================
    pixel_size = traitlets.Float(0.0).tag(sync=True)
    scale_bar_visible = traitlets.Bool(True).tag(sync=True)
    image_width_px = traitlets.Int(0).tag(sync=True)

    # =========================================================================
    # UI Visibility
    # =========================================================================
    show_controls = traitlets.Bool(True).tag(sync=True)
    show_stats = traitlets.Bool(True).tag(sync=True)
    disabled_tools = traitlets.List(traitlets.Unicode()).tag(sync=True)
    hidden_tools = traitlets.List(traitlets.Unicode()).tag(sync=True)
    stats_mean = traitlets.List(traitlets.Float()).tag(sync=True)
    stats_min = traitlets.List(traitlets.Float()).tag(sync=True)
    stats_max = traitlets.List(traitlets.Float()).tag(sync=True)
    stats_std = traitlets.List(traitlets.Float()).tag(sync=True)

    # =========================================================================
    # Analysis Panels (FFT + Histogram shown together)
    # =========================================================================
    show_fft = traitlets.Bool(False).tag(sync=True)

    # =========================================================================
    # Selected Image (for single-image analysis display)
    # =========================================================================
    selected_idx = traitlets.Int(0).tag(sync=True)

    # =========================================================================
    # ROI Selection
    # =========================================================================
    roi_active = traitlets.Bool(False).tag(sync=True)
    roi_list = traitlets.List([]).tag(sync=True)
    roi_selected_idx = traitlets.Int(-1).tag(sync=True)
    roi_stats = traitlets.Dict({}).tag(sync=True)

    # =========================================================================
    # Line Profile
    # =========================================================================
    profile_line = traitlets.List(traitlets.Dict()).tag(sync=True)

    @classmethod
    def _normalize_tool_groups(cls, tool_groups) -> List[str]:
        return normalize_tool_groups("Show2D", tool_groups)

    @classmethod
    def _build_disabled_tools(
        cls,
        disabled_tools=None,
        disable_display: bool = False,
        disable_histogram: bool = False,
        disable_stats: bool = False,
        disable_navigation: bool = False,
        disable_view: bool = False,
        disable_export: bool = False,
        disable_roi: bool = False,
        disable_profile: bool = False,
        disable_all: bool = False,
    ) -> List[str]:
        return build_tool_groups(
            "Show2D",
            tool_groups=disabled_tools,
            all_flag=disable_all,
            flag_map={
                "display": disable_display,
                "histogram": disable_histogram,
                "stats": disable_stats,
                "navigation": disable_navigation,
                "view": disable_view,
                "export": disable_export,
                "roi": disable_roi,
                "profile": disable_profile,
            },
        )

    @classmethod
    def _build_hidden_tools(
        cls,
        hidden_tools=None,
        hide_display: bool = False,
        hide_histogram: bool = False,
        hide_stats: bool = False,
        hide_navigation: bool = False,
        hide_view: bool = False,
        hide_export: bool = False,
        hide_roi: bool = False,
        hide_profile: bool = False,
        hide_all: bool = False,
    ) -> List[str]:
        return build_tool_groups(
            "Show2D",
            tool_groups=hidden_tools,
            all_flag=hide_all,
            flag_map={
                "display": hide_display,
                "histogram": hide_histogram,
                "stats": hide_stats,
                "navigation": hide_navigation,
                "view": hide_view,
                "export": hide_export,
                "roi": hide_roi,
                "profile": hide_profile,
            },
        )

    @traitlets.validate("disabled_tools")
    def _validate_disabled_tools(self, proposal):
        return self._normalize_tool_groups(proposal["value"])

    @traitlets.validate("hidden_tools")
    def _validate_hidden_tools(self, proposal):
        return self._normalize_tool_groups(proposal["value"])

    @classmethod
    def _normalize_reduce_mode(cls, mode: str | None) -> str | None:
        if mode is None:
            return None
        key = str(mode).strip().lower()
        aliases = {"slice": "index"}
        key = aliases.get(key, key)
        if key not in _REDUCE_MODES:
            supported = ", ".join(sorted(_REDUCE_MODES))
            raise ValueError(f"Unknown reduce mode {mode!r}. Supported modes: {supported}.")
        return key

    @classmethod
    def _normalize_folder_file_type(cls, file_type: str | None) -> str:
        if file_type is None:
            raise ValueError("file_type is required for folder loading. Use 'png', 'tiff', or 'emd'.")
        value = str(file_type).strip().lower()
        aliases = {"tif": "tiff"}
        value = aliases.get(value, value)
        if value not in {"png", "tiff", "emd"}:
            raise ValueError("folder file_type must be one of: 'png', 'tiff', 'emd'.")
        return value

    @classmethod
    def _load_image_2d(cls, path: pathlib.Path) -> np.ndarray:
        from PIL import Image

        with Image.open(path) as img:
            return np.asarray(img.convert("F"), dtype=np.float32)

    @classmethod
    def _load_tiff_stack(cls, path: pathlib.Path) -> tuple[np.ndarray, list[str]]:
        from PIL import Image, ImageSequence

        frames: list[np.ndarray] = []
        labels: list[str] = []
        with Image.open(path) as img:
            for i, page in enumerate(ImageSequence.Iterator(img)):
                frame = np.asarray(page.convert("F"), dtype=np.float32)
                frames.append(frame)
                labels.append(f"{path.stem}[{i}]")

        if not frames:
            raise ValueError(f"No readable frames found in TIFF file: {path}")

        shape0 = frames[0].shape
        for i, frame in enumerate(frames[1:], start=1):
            if frame.shape != shape0:
                raise ValueError(
                    f"Inconsistent TIFF frame shapes in {path}: frame 0={shape0}, frame {i}={frame.shape}"
                )
        return np.stack(frames, axis=0).astype(np.float32), labels

    @classmethod
    def _find_best_h5_dataset(cls, h5f):
        candidates: list[tuple[int, str, object]] = []

        def _walk(group, prefix: str = ""):
            for key, item in group.items():
                item_path = f"{prefix}/{key}" if prefix else key
                if hasattr(item, "shape") and hasattr(item, "dtype"):
                    try:
                        ndim = int(item.ndim)
                        size = int(item.size)
                        dtype_kind = str(item.dtype.kind)
                    except Exception:
                        continue
                    if size <= 0 or ndim < 2 or dtype_kind not in {"i", "u", "f", "c"}:
                        continue

                    score = size
                    if ndim == 2:
                        score += 10**15
                    elif ndim == 3:
                        score += 9 * 10**14
                    elif ndim == 4:
                        score += 8 * 10**14
                    elif ndim == 5:
                        score += 7 * 10**14

                    lower_path = item_path.lower()
                    for token in ["image", "stack", "series", "frame", "signal", "data"]:
                        if token in lower_path:
                            score += 10**12
                    for token in ["preview", "thumb", "mask", "meta", "label", "calib"]:
                        if token in lower_path:
                            score -= 10**12

                    candidates.append((score, item_path, item))
                elif hasattr(item, "items"):
                    _walk(item, item_path)

        _walk(h5f)
        if not candidates:
            return "", None
        candidates.sort(key=lambda item: item[0], reverse=True)
        _, ds_path, ds = candidates[0]
        return ds_path, ds

    @classmethod
    def _load_emd_array(cls, path: pathlib.Path, *, dataset_path: str | None = None) -> np.ndarray:
        if not _HAS_H5PY:
            raise RuntimeError("h5py is required to read .emd files. Install h5py to enable EMD loading.")

        with h5py.File(path, "r") as h5f:  # type: ignore[name-defined]
            if dataset_path is not None:
                ds_path = str(dataset_path).strip()
                if not ds_path:
                    raise ValueError("dataset_path must be a non-empty string when provided.")
                if ds_path not in h5f and ds_path.startswith("/") and ds_path[1:] in h5f:
                    ds_path = ds_path[1:]
                if ds_path not in h5f:
                    raise ValueError(f"dataset_path '{dataset_path}' not found in EMD file: {path}")
                ds = h5f[ds_path]
            else:
                ds_path, ds = cls._find_best_h5_dataset(h5f)
            if ds is None:
                raise ValueError(f"No array-like dataset found in EMD file: {path}")
            if not hasattr(ds, "shape") or not hasattr(ds, "dtype"):
                raise ValueError(f"dataset_path '{ds_path}' is not an array dataset in EMD file: {path}")
            arr = np.asarray(ds)
        return arr

    @classmethod
    def _as_stack_3d(cls, arr: np.ndarray) -> np.ndarray:
        if np.iscomplexobj(arr):
            arr = np.abs(arr)
        if arr.ndim < 2:
            raise ValueError(f"Expected at least 2D image data, got {arr.ndim}D")
        if arr.ndim == 2:
            return np.asarray(arr[None, ...], dtype=np.float32)
        if arr.ndim == 3:
            return np.asarray(arr, dtype=np.float32)
        stack = np.asarray(arr).reshape((-1, arr.shape[-2], arr.shape[-1]))
        return np.asarray(stack, dtype=np.float32)

    @classmethod
    def _reduce_stack(cls, stack: np.ndarray, *, mode: str, index: int = 0) -> np.ndarray:
        if stack.ndim != 3:
            raise ValueError(f"Expected 3D stack for reduction, got {stack.ndim}D")
        if mode == "first":
            frame = stack[0]
        elif mode == "index":
            idx = int(index) % stack.shape[0]
            frame = stack[idx]
        elif mode == "mean":
            frame = np.mean(stack, axis=0)
        elif mode == "max":
            frame = np.max(stack, axis=0)
        elif mode == "sum":
            frame = np.sum(stack, axis=0)
        else:
            raise ValueError(f"Unsupported reduce mode: {mode}")
        return np.asarray(frame, dtype=np.float32)

    @classmethod
    def _load_folder_stack(
        cls,
        folder: pathlib.Path,
        *,
        file_type: str,
        dataset_path: str | None = None,
    ) -> tuple[np.ndarray, list[str]]:
        allowed_exts = {".emd", ".png", ".tif", ".tiff"}
        all_files = sorted(p for p in folder.iterdir() if p.is_file() and p.suffix.lower() in allowed_exts)
        if not all_files:
            raise ValueError(f"No supported files found in {folder}. Expected .png, .tif/.tiff, or .emd.")

        selected_type = cls._normalize_folder_file_type(file_type)
        if selected_type != "emd" and dataset_path is not None:
            raise ValueError("dataset_path is only supported for EMD folder loading.")

        if selected_type == "png":
            files = [p for p in all_files if p.suffix.lower() == ".png"]
        elif selected_type == "tiff":
            files = [p for p in all_files if p.suffix.lower() in {".tif", ".tiff"}]
        else:
            files = [p for p in all_files if p.suffix.lower() == ".emd"]

        if not files:
            raise ValueError(f"No {selected_type.upper()} files found in {folder}.")

        frames: list[np.ndarray] = []
        labels: list[str] = []
        if selected_type == "png":
            for p in files:
                frames.append(cls._load_image_2d(p))
                labels.append(p.name)
        elif selected_type == "tiff":
            for p in files:
                stack, _ = cls._load_tiff_stack(p)
                if stack.shape[0] == 1:
                    frames.append(stack[0])
                    labels.append(p.name)
                else:
                    for i in range(stack.shape[0]):
                        frames.append(stack[i])
                        labels.append(f"{p.stem}[{i}]")
        else:
            for p in files:
                arr = cls._load_emd_array(p, dataset_path=dataset_path)
                stack = cls._as_stack_3d(np.asarray(arr))
                if stack.shape[0] == 1:
                    frames.append(stack[0])
                    labels.append(p.name)
                else:
                    for i in range(stack.shape[0]):
                        frames.append(stack[i])
                        labels.append(f"{p.stem}[{i}]")

        shape0 = frames[0].shape
        for i, frame in enumerate(frames[1:], start=1):
            if frame.shape != shape0:
                raise ValueError(
                    f"Inconsistent image shapes in folder {folder}: frame 0={shape0}, frame {i}={frame.shape}"
                )
        return np.stack(frames, axis=0).astype(np.float32), labels

    @classmethod
    def from_path(
        cls,
        source: str | pathlib.Path,
        *,
        file_type: str | None = None,
        dataset_path: str | None = None,
        mode: str | None = None,
        index: int = 0,
        **kwargs,
    ) -> Self:
        """Create Show2D from file/folder input.

        Parameters
        ----------
        source : str or pathlib.Path
            File path (.png/.tif/.tiff/.emd) or folder path.
        file_type : {"png", "tiff", "emd"}, optional
            Required for folder sources to select which files to load.
        dataset_path : str, optional
            Explicit HDF dataset path for `.emd` inputs.
        mode : {"first", "index", "mean", "max", "sum"}, optional
            Optional reduction mode to collapse loaded stack to a single 2D image.
            If omitted, stacks are shown in Show2D gallery mode.
        index : int, default 0
            Stack index used by ``mode="index"``.
        """
        path = pathlib.Path(source)
        reduce_mode = cls._normalize_reduce_mode(mode)

        if path.is_dir():
            stack, labels = cls._load_folder_stack(path, file_type=file_type, dataset_path=dataset_path)
            kwargs.setdefault("title", path.name)
            if reduce_mode is None:
                kwargs.setdefault("labels", labels)
                return cls(stack, **kwargs)
            image = cls._reduce_stack(stack, mode=reduce_mode, index=index)
            return cls(image, **kwargs)

        if not path.is_file():
            raise ValueError(f"Path does not exist: {path}")
        if file_type is not None:
            raise ValueError("file_type is only used for folder sources.")

        ext = path.suffix.lower()
        if ext == ".png":
            if dataset_path is not None:
                raise ValueError("dataset_path is only supported for .emd inputs.")
            image = cls._load_image_2d(path)
            kwargs.setdefault("title", path.stem)
            return cls(image, **kwargs)

        if ext in {".tif", ".tiff"}:
            if dataset_path is not None:
                raise ValueError("dataset_path is only supported for .emd inputs.")
            stack, labels = cls._load_tiff_stack(path)
            kwargs.setdefault("title", path.stem)
            if reduce_mode is None:
                kwargs.setdefault("labels", labels)
                return cls(stack, **kwargs)
            image = cls._reduce_stack(stack, mode=reduce_mode, index=index)
            return cls(image, **kwargs)

        if ext == ".emd":
            arr = cls._load_emd_array(path, dataset_path=dataset_path)
            stack = cls._as_stack_3d(np.asarray(arr))
            kwargs.setdefault("title", path.stem)
            if reduce_mode is None:
                labels = [f"{path.stem}[{i}]" for i in range(stack.shape[0])]
                kwargs.setdefault("labels", labels)
                return cls(stack, **kwargs)
            image = cls._reduce_stack(stack, mode=reduce_mode, index=index)
            return cls(image, **kwargs)

        raise ValueError(
            f"Unsupported file type: {path.suffix}. Use .png, .tif, .tiff, .emd, or a folder of one explicit type."
        )

    @classmethod
    def from_folder(
        cls,
        folder: str | pathlib.Path,
        *,
        file_type: str,
        dataset_path: str | None = None,
        mode: str | None = None,
        index: int = 0,
        **kwargs,
    ) -> Self:
        """Create Show2D from a folder with explicit file type selection."""
        return cls.from_path(
            folder,
            file_type=file_type,
            dataset_path=dataset_path,
            mode=mode,
            index=index,
            **kwargs,
        )

    @classmethod
    def from_png(cls, source: str | pathlib.Path, **kwargs) -> Self:
        """Create Show2D from a single PNG file."""
        return cls.from_path(source, **kwargs)

    @classmethod
    def from_tiff(
        cls,
        source: str | pathlib.Path,
        *,
        mode: str | None = None,
        index: int = 0,
        **kwargs,
    ) -> Self:
        """Create Show2D from a TIFF file."""
        return cls.from_path(source, mode=mode, index=index, **kwargs)

    @classmethod
    def from_emd(
        cls,
        source: str | pathlib.Path,
        *,
        dataset_path: str | None = None,
        mode: str | None = None,
        index: int = 0,
        **kwargs,
    ) -> Self:
        """Create Show2D from an EMD file."""
        return cls.from_path(source, dataset_path=dataset_path, mode=mode, index=index, **kwargs)

    @classmethod
    def from_png_folder(
        cls,
        folder: str | pathlib.Path,
        *,
        mode: str | None = None,
        index: int = 0,
        **kwargs,
    ) -> Self:
        """Create Show2D from a folder of PNG files."""
        return cls.from_folder(folder, file_type="png", mode=mode, index=index, **kwargs)

    @classmethod
    def from_tiff_folder(
        cls,
        folder: str | pathlib.Path,
        *,
        mode: str | None = None,
        index: int = 0,
        **kwargs,
    ) -> Self:
        """Create Show2D from a folder of TIFF files."""
        return cls.from_folder(folder, file_type="tiff", mode=mode, index=index, **kwargs)

    @classmethod
    def from_emd_folder(
        cls,
        folder: str | pathlib.Path,
        *,
        dataset_path: str | None = None,
        mode: str | None = None,
        index: int = 0,
        **kwargs,
    ) -> Self:
        """Create Show2D from a folder of EMD files."""
        return cls.from_folder(
            folder,
            file_type="emd",
            dataset_path=dataset_path,
            mode=mode,
            index=index,
            **kwargs,
        )

    def __init__(
        self,
        data: Union[np.ndarray, List[np.ndarray]],
        labels: Optional[List[str]] = None,
        title: str = "",
        cmap: Union[str, Colormap] = Colormap.INFERNO,
        pixel_size: float = 0.0,
        scale_bar_visible: bool = True,
        show_fft: bool = False,
        show_controls: bool = True,
        show_stats: bool = True,
        log_scale: bool = False,
        auto_contrast: bool = False,
        disabled_tools: Optional[List[str]] = None,
        disable_display: bool = False,
        disable_histogram: bool = False,
        disable_stats: bool = False,
        disable_navigation: bool = False,
        disable_view: bool = False,
        disable_export: bool = False,
        disable_roi: bool = False,
        disable_profile: bool = False,
        disable_all: bool = False,
        hidden_tools: Optional[List[str]] = None,
        hide_display: bool = False,
        hide_histogram: bool = False,
        hide_stats: bool = False,
        hide_navigation: bool = False,
        hide_view: bool = False,
        hide_export: bool = False,
        hide_roi: bool = False,
        hide_profile: bool = False,
        hide_all: bool = False,
        ncols: int = 3,
        image_width_px: int = 0,
        state=None,
        **kwargs,
    ):
        super().__init__(**kwargs)
        self.widget_version = resolve_widget_version()

        # Check if data is a Dataset2d and extract metadata
        if hasattr(data, "array") and hasattr(data, "name") and hasattr(data, "sampling"):
            if not title and data.name:
                title = data.name
            if pixel_size == 0.0 and hasattr(data, "units"):
                units = list(data.units)
                sampling_val = float(data.sampling[-1])
                if units[-1] in ("nm",):
                    pixel_size = sampling_val * 10  # nm → Å
                elif units[-1] in ("Å", "angstrom", "A"):
                    pixel_size = sampling_val
            data = data.array

        # Convert input to NumPy (handles NumPy, CuPy, PyTorch)
        if isinstance(data, list):
            images = [to_numpy(d) for d in data]

            # Check if all images have the same shape
            shapes = [img.shape for img in images]
            if len(set(shapes)) > 1:
                # Different sizes - resize all to the largest
                max_h = max(s[0] for s in shapes)
                max_w = max(s[1] for s in shapes)
                images = [_resize_image(img, max_h, max_w) for img in images]

            data = np.stack(images)
        else:
            data = to_numpy(data)

        # Ensure 3D shape (N, H, W)
        if data.ndim == 2:
            data = data[np.newaxis, ...]

        self._data = data.astype(np.float32)
        self.n_images = int(data.shape[0])
        self.height = int(data.shape[1])
        self.width = int(data.shape[2])

        # Labels
        if labels is None:
            self.labels = [f"Image {i+1}" for i in range(self.n_images)]
        else:
            self.labels = list(labels)

        # Options
        self.title = title
        self.cmap = cmap
        self.pixel_size = pixel_size
        self.scale_bar_visible = scale_bar_visible
        self.image_width_px = image_width_px
        self.show_fft = show_fft
        self.show_controls = show_controls
        self.show_stats = show_stats
        self.log_scale = log_scale
        self.auto_contrast = auto_contrast
        self.disabled_tools = self._build_disabled_tools(
            disabled_tools=disabled_tools,
            disable_display=disable_display,
            disable_histogram=disable_histogram,
            disable_stats=disable_stats,
            disable_navigation=disable_navigation,
            disable_view=disable_view,
            disable_export=disable_export,
            disable_roi=disable_roi,
            disable_profile=disable_profile,
            disable_all=disable_all,
        )
        self.hidden_tools = self._build_hidden_tools(
            hidden_tools=hidden_tools,
            hide_display=hide_display,
            hide_histogram=hide_histogram,
            hide_stats=hide_stats,
            hide_navigation=hide_navigation,
            hide_view=hide_view,
            hide_export=hide_export,
            hide_roi=hide_roi,
            hide_profile=hide_profile,
            hide_all=hide_all,
        )
        self.ncols = ncols

        # Compute initial stats
        self._compute_all_stats()

        # Send raw float32 data to JS (normalization happens in JS for speed)
        self._update_all_frames()

        self.selected_idx = 0

        if state is not None:
            if isinstance(state, (str, pathlib.Path)):
                state = unwrap_state_payload(
                    json.loads(pathlib.Path(state).read_text()),
                    require_envelope=True,
                )
            else:
                state = unwrap_state_payload(state)
            self.load_state_dict(state)

    def set_image(self, data, labels=None):
        """Replace the displayed image(s). Preserves all display settings."""
        if hasattr(data, "array") and hasattr(data, "name") and hasattr(data, "sampling"):
            data = data.array
        if isinstance(data, list):
            images = [to_numpy(d) for d in data]
            shapes = [img.shape for img in images]
            if len(set(shapes)) > 1:
                max_h = max(s[0] for s in shapes)
                max_w = max(s[1] for s in shapes)
                images = [_resize_image(img, max_h, max_w) for img in images]
            data = np.stack(images)
        else:
            data = to_numpy(data)
        if data.ndim == 2:
            data = data[np.newaxis, ...]
        self._data = data.astype(np.float32)
        self.n_images = int(data.shape[0])
        self.height = int(data.shape[1])
        self.width = int(data.shape[2])
        if labels is not None:
            self.labels = list(labels)
        else:
            self.labels = [f"Image {i+1}" for i in range(self.n_images)]
        self.selected_idx = 0
        self._compute_all_stats()
        self._update_all_frames()

    def __repr__(self) -> str:
        if self.n_images > 1:
            shape = f"{self.n_images}×{self.height}×{self.width}"
            return f"Show2D({shape}, idx={self.selected_idx}, cmap={self.cmap})"
        return f"Show2D({self.height}×{self.width}, cmap={self.cmap})"

    def _repr_mimebundle_(self, **kwargs):
        """Return widget view + static PNG fallback.

        Live Jupyter renders the interactive widget. Static contexts
        (nbsphinx, GitHub, nbviewer) fall back to the embedded PNG.
        """
        bundle = super()._repr_mimebundle_(**kwargs)
        data_dict = bundle[0] if isinstance(bundle, tuple) else bundle
        n = self.n_images
        ncols = min(self.ncols, n)
        nrows = math.ceil(n / ncols)
        cell = 4
        fig, axes = plt.subplots(
            nrows, ncols,
            figsize=(cell * ncols, cell * nrows),
            squeeze=False,
        )
        for i in range(nrows * ncols):
            r, c = divmod(i, ncols)
            ax = axes[r][c]
            if i < n:
                ax.imshow(self._data[i], cmap=self.cmap, origin="upper")
                ax.set_title(self.labels[i], fontsize=10)
            ax.axis("off")
        if self.title:
            fig.suptitle(self.title, fontsize=12)
        fig.tight_layout()
        buf = io.BytesIO()
        fig.savefig(buf, format="png", dpi=120, bbox_inches="tight")
        plt.close(fig)
        data_dict["image/png"] = base64.b64encode(buf.getvalue()).decode("ascii")
        if isinstance(bundle, tuple):
            return (data_dict, bundle[1])
        return data_dict

    def state_dict(self):
        return {
            "title": self.title,
            "cmap": self.cmap,
            "log_scale": self.log_scale,
            "auto_contrast": self.auto_contrast,
            "show_stats": self.show_stats,
            "show_fft": self.show_fft,
            "show_controls": self.show_controls,
            "disabled_tools": self.disabled_tools,
            "hidden_tools": self.hidden_tools,
            "pixel_size": self.pixel_size,
            "scale_bar_visible": self.scale_bar_visible,
            "image_width_px": self.image_width_px,
            "ncols": self.ncols,
            "selected_idx": self.selected_idx,
            "roi_active": self.roi_active,
            "roi_list": self.roi_list,
            "roi_selected_idx": self.roi_selected_idx,
            "profile_line": self.profile_line,
        }

    def save(self, path: str):
        save_state_file(path, "Show2D", self.state_dict())

    def load_state_dict(self, state):
        for key, val in state.items():
            if key == "pixel_size_angstrom":
                key = "pixel_size"
            if hasattr(self, key):
                setattr(self, key, val)

    def summary(self):
        lines = [self.title or "Show2D", "═" * 32]
        if self.n_images > 1:
            lines.append(f"Image:    {self.n_images}×{self.height}×{self.width} ({self.ncols} cols)")
        else:
            lines.append(f"Image:    {self.height}×{self.width}")
        if self.pixel_size > 0:
            ps = self.pixel_size
            if ps >= 10:
                lines[-1] += f" ({ps / 10:.2f} nm/px)"
            else:
                lines[-1] += f" ({ps:.2f} Å/px)"
        if hasattr(self, "_data") and self._data is not None:
            arr = self._data
            lines.append(f"Data:     min={float(arr.min()):.4g}  max={float(arr.max()):.4g}  mean={float(arr.mean()):.4g}")
        cmap = self.cmap
        scale = "log" if self.log_scale else "linear"
        contrast = "auto contrast" if self.auto_contrast else "manual contrast"
        display = f"{cmap} | {contrast} | {scale}"
        if self.show_fft:
            display += " | FFT"
        lines.append(f"Display:  {display}")
        if self.disabled_tools:
            lines.append(f"Locked:   {', '.join(self.disabled_tools)}")
        if self.hidden_tools:
            lines.append(f"Hidden:   {', '.join(self.hidden_tools)}")
        if self.roi_active and self.roi_list:
            lines.append(f"ROI:      {len(self.roi_list)} region(s)")
        if self.profile_line:
            p0, p1 = self.profile_line[0], self.profile_line[1]
            lines.append(f"Profile:  ({p0['row']:.0f}, {p0['col']:.0f}) → ({p1['row']:.0f}, {p1['col']:.0f})")
        print("\n".join(lines))

    def _compute_all_stats(self):
        """Compute statistics for all images."""
        means, mins, maxs, stds = [], [], [], []
        for i in range(self.n_images):
            img = self._data[i]
            means.append(float(np.mean(img)))
            mins.append(float(np.min(img)))
            maxs.append(float(np.max(img)))
            stds.append(float(np.std(img)))
        self.stats_mean = means
        self.stats_min = mins
        self.stats_max = maxs
        self.stats_std = stds

    def _update_all_frames(self):
        """Send raw float32 data to JS (normalization happens in JS for speed)."""
        self.frame_bytes = self._data.tobytes()

    def _sample_profile(self, row0, col0, row1, col1):
        img = self._data[self.selected_idx]
        h, w = img.shape
        dc, dr = col1 - col0, row1 - row0
        length = (dc**2 + dr**2) ** 0.5
        n = max(2, int(np.ceil(length)))
        t = np.linspace(0, 1, n)
        cs = col0 + t * dc
        rs = row0 + t * dr
        ci = np.floor(cs).astype(int)
        ri = np.floor(rs).astype(int)
        cf = cs - ci
        rf = rs - ri
        c0c = np.clip(ci, 0, w - 1)
        c1c = np.clip(ci + 1, 0, w - 1)
        r0c = np.clip(ri, 0, h - 1)
        r1c = np.clip(ri + 1, 0, h - 1)
        return (img[r0c, c0c] * (1 - cf) * (1 - rf) +
                img[r0c, c1c] * cf * (1 - rf) +
                img[r1c, c0c] * (1 - cf) * rf +
                img[r1c, c1c] * cf * rf).astype(np.float32)

    def set_profile(self, start: tuple, end: tuple):
        """Set a line profile between two points (image pixel coordinates).

        Parameters
        ----------
        start : tuple of (row, col)
            Start point in pixel coordinates.
        end : tuple of (row, col)
            End point in pixel coordinates.
        """
        row0, col0 = start
        row1, col1 = end
        self.profile_line = [
            {"row": float(row0), "col": float(col0)},
            {"row": float(row1), "col": float(col1)},
        ]

    def clear_profile(self):
        """Clear the current line profile."""
        self.profile_line = []

    @property
    def profile(self):
        """Get profile line endpoints as [(row0, col0), (row1, col1)] or [].

        Returns
        -------
        list of tuple
            Line endpoints in pixel coordinates, or empty list if no profile.
        """
        return [(p["row"], p["col"]) for p in self.profile_line]

    @property
    def profile_values(self):
        """Get intensity values along the profile line as a numpy array.

        Returns
        -------
        np.ndarray or None
            Float32 array of sampled intensities, or None if no profile.
        """
        if len(self.profile_line) < 2:
            return None
        p0, p1 = self.profile_line
        return self._sample_profile(p0["row"], p0["col"], p1["row"], p1["col"])

    @property
    def profile_distance(self):
        """Get total distance of the profile line in calibrated units.

        Returns
        -------
        float or None
            Distance in angstroms (if pixel_size > 0) or pixels.
            None if no profile line is set.
        """
        if len(self.profile_line) < 2:
            return None
        p0, p1 = self.profile_line
        dc = p1["col"] - p0["col"]
        dr = p1["row"] - p0["row"]
        dist_px = (dc**2 + dr**2) ** 0.5
        if self.pixel_size > 0:
            return dist_px * self.pixel_size
        return dist_px

    @traitlets.observe("roi_active", "roi_list", "roi_selected_idx", "selected_idx")
    def _on_roi_change(self, change=None):
        if self.roi_active:
            self._update_roi_stats()
        else:
            self.roi_stats = {}

    def _update_roi_stats(self):
        idx = self.roi_selected_idx
        if idx < 0 or idx >= len(self.roi_list):
            self.roi_stats = {}
            return
        roi = self.roi_list[idx]
        img = self._data[self.selected_idx]
        h, w = img.shape
        r, c = np.ogrid[:h, :w]
        shape = roi.get("shape", "circle")
        row, col = roi.get("row", 0), roi.get("col", 0)
        radius = roi.get("radius", 10)
        if shape == "circle":
            mask = (c - col) ** 2 + (r - row) ** 2 <= radius**2
        elif shape == "square":
            mask = (np.abs(c - col) <= radius) & (np.abs(r - row) <= radius)
        elif shape == "rectangle":
            half_w = roi.get("width", 20) // 2
            half_h = roi.get("height", 20) // 2
            mask = (np.abs(c - col) <= half_w) & (np.abs(r - row) <= half_h)
        elif shape == "annular":
            dist2 = (c - col) ** 2 + (r - row) ** 2
            inner = roi.get("radius_inner", 5)
            mask = (dist2 >= inner**2) & (dist2 <= radius**2)
        else:
            mask = (c - col) ** 2 + (r - row) ** 2 <= radius**2
        region = img[mask]
        if region.size > 0:
            self.roi_stats = {
                "mean": float(region.mean()),
                "min": float(region.min()),
                "max": float(region.max()),
                "std": float(region.std()),
            }
        else:
            self.roi_stats = {}


bind_tool_runtime_api(Show2D, "Show2D")
